// Package models contains the types for schema 'blog'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"errors"
	"strings"
)

// AuthorTableHeader is the columns within the blog.authors table.
var AuthorTableHeader = []string{
	"id",
	"email",
	"name",
	"hashed_password",
}

// Author represents a row from 'blog.authors'.
type Author struct {
	ID             int    `db:"id"`              // id
	Email          string `db:"email"`           // email
	Name           string `db:"name"`            // name
	HashedPassword string `db:"hashed_password"` // hashed_password

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Author exists in the database.
func (a *Author) Exists() bool {
	return a._exists
}

// Deleted provides information if the Author has been deleted from the database.
func (a *Author) Deleted() bool {
	return a._deleted
}

// Insert inserts the Author to the database.
func (a *Author) Insert(ctx context.Context, db XODB) error {
	var err error

	// if already exist, bail
	if a._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = "INSERT INTO blog.authors (" +
		"email, name, hashed_password" +
		") VALUES (" +
		"?, ?, ?" +
		")"

	// run query
	res, err := db.ExecContext(ctx, sqlstr, a.Email, a.Name, a.HashedPassword)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	a.ID = int(id)
	a._exists = true

	return nil
}

// Update updates the Author in the database.
func (a *Author) Update(ctx context.Context, db XODB) error {
	var err error

	// if doesn't exist, bail
	if !a._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if a._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = "UPDATE blog.authors SET " +
		"email = ?, name = ?, hashed_password = ?" +
		" WHERE id = ?"

	// run query
	_, err = db.ExecContext(ctx, sqlstr, a.Email, a.Name, a.HashedPassword, a.ID)
	return err
}

// Save saves the Author to the database.
func (a *Author) Save(ctx context.Context, db XODB) error {
	if a.Exists() {
		return a.Update(ctx, db)
	}

	return a.Insert(ctx, db)
}

// Delete deletes the Author from the database.
func (a *Author) Delete(ctx context.Context, db XODB) error {
	var err error

	// if doesn't exist, bail
	if !a._exists {
		return nil
	}

	// if deleted, bail
	if a._deleted {
		return nil
	}

	// sql query
	const sqlstr = "DELETE FROM blog.authors WHERE id = ?"

	// run query
	_, err = db.ExecContext(ctx, sqlstr, a.ID)
	if err != nil {
		return err
	}

	// set deleted
	a._deleted = true

	return nil
}

func BulkInsertAuthors(ctx context.Context, db XODB, as []*Author) error {
	for i := 0; i < len(as); i += chunkSize {
		end := i + chunkSize
		if end > len(as) {
			end = len(as)
		}

		chunk := as[i:end]

		placeholders := strings.Repeat(", (?, ?, ?)", len(chunk))[2:]

		// sql insert query, primary key provided by autoincrement
		sqlstr := "INSERT INTO blog.authors (email, name, hashed_password)" +
			"VALUES " +
			placeholders

		var args []interface{}
		for _, a := range chunk {
			args = append(args, a.Email, a.Name, a.HashedPassword)
		}

		// run query
		res, err := db.ExecContext(ctx, sqlstr, args...)
		if err != nil {
			return err
		}

		// for bulk inserts, the last insert id will be the id of the first inserted row
		id, err := res.LastInsertId()
		if err != nil {
			return err
		}

		// set primary key and existance
		for _, a := range chunk {
			a.ID = int(id)
			a._exists = true
			id++
		}
	}

	return nil
}

// AuthorByID retrieves a row from 'blog.authors' as a Author.
//
// Generated from index 'authors_id_pkey'.
func AuthorByID(ctx context.Context, db XODB, id int) (*Author, error) {
	var err error

	// sql query
	const sqlstr = "SELECT " +
		"id, email, name, hashed_password " +
		"FROM blog.authors " +
		"WHERE id = ?"

	// run query
	a := Author{
		_exists: true,
	}

	err = db.QueryRowContext(ctx, sqlstr, id).Scan(&a.ID, &a.Email, &a.Name, &a.HashedPassword)
	if err != nil {
		return nil, err
	}

	return &a, nil
}

// AuthorByEmail retrieves a row from 'blog.authors' as a Author.
//
// Generated from index 'email'.
func AuthorByEmail(ctx context.Context, db XODB, email string) (*Author, error) {
	var err error

	// sql query
	const sqlstr = "SELECT " +
		"id, email, name, hashed_password " +
		"FROM blog.authors " +
		"WHERE email = ?"

	// run query
	a := Author{
		_exists: true,
	}

	err = db.QueryRowContext(ctx, sqlstr, email).Scan(&a.ID, &a.Email, &a.Name, &a.HashedPassword)
	if err != nil {
		return nil, err
	}

	return &a, nil
}
