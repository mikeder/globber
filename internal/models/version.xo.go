// Package models contains the types for schema 'blog'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"strings"
)

// VersionTableHeader is the columns within the blog.version table.
var VersionTableHeader = []string{
	"id",
	"applied",
	"author",
	"version",
}

// Version represents a row from 'blog.version'.
type Version struct {
	ID      int     `db:"id"`      // id
	Applied string  `db:"applied"` // applied
	Author  string  `db:"author"`  // author
	Version float32 `db:"version"` // version

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Version exists in the database.
func (v *Version) Exists() bool {
	return v._exists
}

// Deleted provides information if the Version has been deleted from the database.
func (v *Version) Deleted() bool {
	return v._deleted
}

// Insert inserts the Version to the database.
func (v *Version) Insert(ctx context.Context, db XODB) error {
	var err error

	// if already exist, bail
	if v._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = "INSERT INTO blog.version (" +
		"applied, author, version" +
		") VALUES (" +
		"?, ?, ?" +
		")"

	// run query
	res, err := db.ExecContext(ctx, sqlstr, v.Applied, v.Author, v.Version)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	v.ID = int(id)
	v._exists = true

	return nil
}

// Update updates the Version in the database.
func (v *Version) Update(ctx context.Context, db XODB) error {
	var err error

	// if doesn't exist, bail
	if !v._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if v._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = "UPDATE blog.version SET " +
		"applied = ?, author = ?, version = ?" +
		" WHERE id = ?"

	// run query
	_, err = db.ExecContext(ctx, sqlstr, v.Applied, v.Author, v.Version, v.ID)
	return err
}

// Save saves the Version to the database.
func (v *Version) Save(ctx context.Context, db XODB) error {
	if v.Exists() {
		return v.Update(ctx, db)
	}

	return v.Insert(ctx, db)
}

// Delete deletes the Version from the database.
func (v *Version) Delete(ctx context.Context, db XODB) error {
	var err error

	// if doesn't exist, bail
	if !v._exists {
		return nil
	}

	// if deleted, bail
	if v._deleted {
		return nil
	}

	// sql query
	const sqlstr = "DELETE FROM blog.version WHERE id = ?"

	// run query
	_, err = db.ExecContext(ctx, sqlstr, v.ID)
	if err != nil {
		return err
	}

	// set deleted
	v._deleted = true

	return nil
}

func BulkInsertVersions(ctx context.Context, db XODB, vs []*Version) error {
	for i := 0; i < len(vs); i += chunkSize {
		end := i + chunkSize
		if end > len(vs) {
			end = len(vs)
		}

		chunk := vs[i:end]

		placeholders := strings.Repeat(", (?, ?, ?)", len(chunk))[2:]

		// sql insert query, primary key provided by autoincrement
		sqlstr := "INSERT INTO blog.version (applied, author, version)" +
			"VALUES " +
			placeholders

		var args []interface{}
		for _, v := range chunk {
			args = append(args, v.Applied, v.Author, v.Version)
		}

		// run query
		res, err := db.ExecContext(ctx, sqlstr, args...)
		if err != nil {
			return err
		}

		// for bulk inserts, the last insert id will be the id of the first inserted row
		id, err := res.LastInsertId()
		if err != nil {
			return err
		}

		// set primary key and existance
		for _, v := range chunk {
			v.ID = int(id)
			v._exists = true
			id++
		}
	}

	return nil
}

// VersionByID retrieves a row from 'blog.version' as a Version.
//
// Generated from index 'version_id_pkey'.
func VersionByID(ctx context.Context, db XODB, id int) (*Version, error) {
	var err error

	// sql query
	const sqlstr = "SELECT " +
		"id, applied, author, version " +
		"FROM blog.version " +
		"WHERE id = ?"

	// run query
	v := Version{
		_exists: true,
	}

	err = db.QueryRowContext(ctx, sqlstr, id).Scan(&v.ID, &v.Applied, &v.Author, &v.Version)
	if err != nil {
		return nil, err
	}

	return &v, nil
}
